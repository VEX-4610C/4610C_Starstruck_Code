#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           backLeft,      tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port3,           frontRight,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           frontLeft,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port10,          backRight,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define SIGN(n) (n<0 ? -1 : 1)
void gyroturn(int deg)
{
	int gyroticks = deg*10;
	int P_Factor = 2.5;
	SensorValue[gyro] = 0;
	while(abs(SensorValue[gyro]) < abs(gyroticks))
	{
		motor[backLeft] = SIGN(gyroticks)*((abs(gyroticks)-abs(SensorValue[gyro]))*P_Factor);
		motor[backRight] = SIGN(gyroticks)*((abs(gyroticks)-abs(SensorValue[gyro]))*P_Factor);
		motor[frontLeft] = SIGN(gyroticks)*((abs(gyroticks)-abs(SensorValue[gyro]))*P_Factor);
		motor[frontRight] = SIGN(gyroticks)*((abs(gyroticks)-abs(SensorValue[gyro]))*P_Factor);
	}
	motor[backLeft] = -1*SIGN(gyroticks)*15;
	motor[backRight] = -1*SIGN(gyroticks)*15;
	motor[frontLeft] = -1*SIGN(gyroticks)*15;
	motor[frontRight] = -1*SIGN(gyroticks)*15;
	wait1Msec(150);
	motor[backLeft] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[frontRight] = 0;
	wait1Msec(150);
		
}
int wheeldegs;
void moveForwardsInches(int inches)
{
	wheeldegs = (inches/10.205)*360;
	float P_Factor = 0.75;
	nMotorEncoder[frontLeft] = 0;
	writeDebugStreamLine("%d", wheeldegs);
	while(abs(nMotorEncoder[frontLeft]) < abs(wheeldegs))
	{
		motor[backLeft] = SIGN(wheeldegs)*((abs(nMotorEncoder[frontLeft])-abs(wheeldegs))*P_Factor);
		motor[backRight] = SIGN(wheeldegs)*((abs(nMotorEncoder[frontLeft])-abs(wheeldegs))*P_Factor)*-1;
		motor[frontLeft] = SIGN(wheeldegs)*((abs(nMotorEncoder[frontLeft])-abs(wheeldegs))*P_Factor)*-1;
		motor[frontRight] = SIGN(wheeldegs)*((abs(nMotorEncoder[frontLeft])-abs(wheeldegs))*P_Factor);
	}
	/*motor[backLeft] = -1*SIGN(wheeldegs)*15;
	motor[backRight] = -1*SIGN(wheeldegs)*15;
	motor[frontLeft] = -1*SIGN(wheeldegs)*15;
	motor[frontRight] = -1*SIGN(wheeldegs)*15;
	wait1Msec(150);
	motor[backLeft] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[frontRight] = 0;
	wait1Msec(150);*/
	
}
task main()
{
	SensorType[gyro] = sensorNone;
	wait1Msec(500);
	SensorType[gyro] = sensorGyro;
	wait1Msec(1900);
	//gyroturn(360);
	moveForwardsInches(24);



}
